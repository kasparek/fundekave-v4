/*
 * FilePondPluginFileValidateType 1.1.0
 * Licensed under MIT, https://opensource.org/licenses/MIT
 * Please visit https://pqina.nl/filepond for details.
 */
var plugin$1=({addFilter:e,utils:t})=>{const{Type:E,isString:l,replaceInString:T,guesstimateMimeType:i,getExtensionFromFilename:n,getFilenameFromURL:_}=t,a=(e,t)=>{if(0===t.length)return!0;let E="";if(l(e)){const t=_(e),l=n(t);if(!l)return!0;E=i(l)}else E=e.type;return((e,t)=>e.some(e=>/\*$/.test(e)?((e,E)=>(/^[^/]+/.exec(t)||[]).pop()===E.slice(0,-2))(0,e):e===t))(t,E)};return e("SET_ATTRIBUTE_TO_OPTION_MAP",e=>Object.assign(e,{accept:"acceptedFileTypes"})),e("ALLOW_HOPPER_ITEM",(e,{query:t})=>!t("GET_ALLOW_FILE_TYPE_VALIDATION")||a(e,t("GET_ACCEPTED_FILE_TYPES"))),e("LOAD_FILE",(e,{query:t})=>new Promise((E,l)=>{if(!t("GET_ALLOW_FILE_TYPE_VALIDATION"))return void E(e);const i=t("GET_ACCEPTED_FILE_TYPES");if(a(e,i))E(e);else{const e=i.map((e=>t=>null!==e[t]&&(e[t]||t))(t("GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES_MAP"))).filter(e=>!1!==e);l({status:{main:t("GET_LABEL_FILE_TYPE_NOT_ALLOWED"),sub:T(t("GET_FILE_VALIDATE_TYPE_LABEL_EXPECTED_TYPES"),{allTypes:e.join(", "),allButLastType:e.slice(0,-1).join(", "),lastType:e[e.length-1]})}})}})),{options:{allowFileTypeValidation:[!0,E.BOOLEAN],acceptedFileTypes:[[],E.ARRAY],labelFileTypeNotAllowed:["File is of invalid type",E.STRING],fileValidateTypeLabelExpectedTypes:["Expects {allButLastType} or {lastType}",E.STRING],fileValidateTypeLabelExpectedTypesMap:[{},E.OBJECT]}}};"undefined"!=typeof navigator&&document&&document.dispatchEvent(new CustomEvent("FilePond:pluginloaded",{detail:plugin$1}));export default plugin$1;